---
aliases: ["posts", "articles", "blog", "showcase"]
title: "Dissecting a fresh BlankGrabber sample"
author: "Cedric 'Cyb3rjerry' Brisson"
tags: ["threat hunting", "reverse engineering", "cybersecurity"]
type: "postcard"
toc: true
date: "2025-02-15"
---

# Dissecting a fresh BlankGrabber sample

BlankGrabber is nothing new. It's been documented by multiple companies such as [ThreatMon](https://www.linkedin.com/feed/update/urn:li:activity:7247179869443264512/), [K7Security](https://labs.k7computing.com/index.php/open-source-stealers-oss-python/) and has even had it's source code disclosed on [GitHub](https://github.com/Blank-c/Blank-Grabber). So why exactly are we looking at a well documented and even reversed sample? Because there's more than just the final payload. We a fresh unaltered sample, we get to look into how the sample gets dropped and loaded! 

## How I found this sample

If you've read other blogposts I wrote, you'll know I'm no pro. I'm just a curious dude that's starting to delve into the world of RE because malware has always fascinated me. Aside from the certification I'm currently working on, I really enjoy just grabbing random samples and figuring out how it works. One way of doing so is to simply go on [tria.ge](https://tria.ge), look for public reports that got flagged as malicious and download it. Put simply and quickly, [tria.ge](https://tria.ge) is a free and public dynamic analysis tool that gives you information about a sample by actually detonating it. The results will include interesting details such as PCAPs, dropped files and Windows APIs used.

For this analysis, we'll focus on a bad boy titled "Velocity.exe".

SHA256: 94237eac80fd2a20880180cab19b94e8760f0d1f06715ff42a6f60aef84f4adf <br> 
MD5: 8073f87f61f0625f1ec5ecc24c1c686e <br>
Tria.ge link: https://tria.ge/250213-cswx4s1nhp


I've also uploaded it to malshare if you want to follow along. [link](https://malshare.com/sample.php?action=detail&hash=94237eac80fd2a20880180cab19b94e8760f0d1f06715ff42a6f60aef84f4adf)

## Initial analysis

The three things I like running first on an unknown binary is the following:

1. `file` to get an idea of the type of file I'm dealing with
2. `strings` to see if anything stands out at first glance
3. `Detect It Easy (DIE)` to see if there's some embeded files in there

Upon running `file` on the binary, we can quickly determine it's a [PE](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format) file since the value that's returned is `Velocity.exe: PE32+ executable (GUI) x86-64, for MS Windows, 7 sections`. We can further validate this by getting the first few bytes that match the classic "MZ" (`0x4D 0x5A`) magic number and the classic `This program cannot be run in DOS mode` that's generated by the Linker (default stub).

![Hex dump of the file header](/images/blank-grabber-headers.png)

Finally, we can throw the file into DIE to see if it's packed (or something like that). We quickly notice the file is most likely packed with PyInstaller and that the overlay contains ZLIB compressed data. That's pretty interesting!

![DIE result of the sample](/images/blank-grabber-detectiteasy.png)

Now this gives us a good idea of where we wanna move next. Do we care about how a PyInstaller PE executes? Not really (at least not for now). Instead, we're more interesting in <u>what it installs</u>. How do we find that? We unpack it. In this case, there's some pretty cool tools such as [PyInstaller Extractor](https://github.com/extremecoders-re/pyinstxtractor) but there's some even cooler free tools out there that unpacks the sample but also offers a few goodies. Remember the 3 tools I like to run first on a sample? Turns out a cool ass company out there offers this and even more, for free!

## UnpacMe

> CJ, why are you, yet again, shilling for an online tool?! 

I'm gonna be honest here, I think what they do is absolutely fantastic. The cool studs at OpenAnalysis have managed to put out an easy to use tool that provides all you need for your initial analysis of an unknown sample. More so, the guys at OA make some absolutely crazy good learning content. Here's a video I personally really enjoyed and I highly suggest you give it a glance. They also have a [Patreon page](https://www.patreon.com/c/oalabs/posts) where they post even more detailed lessons and really teach you the fundamentals of RE. Sergei, you're a fantastic teacher.

<iframe width="560" height="315" src="https://www.youtube.com/embed/04RsqP_P9Ss?si=IVH930TtZW0YzpsT" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

This brings us to UnpacMe more specifically. I don't trust myself to accurately describe their services, however, so here's how they define their cool tool:

> UNPACME is an automated malware unpacking service. Submissions to UNPACME are analyzed using a set of custom unpacking processes maintained by OpenAnalysis. These processes extract all encrypted or packed payloads from the submission and return a unique set of payloads to the user. In short, UNPACME automates the first step in your malware analysis process.

Enough bootlicking, let's move into the results. You once again follow along by browsing to the result page [here](https://www.unpac.me/results/d6f19cd9-7edb-4e1d-9668-69f26afe540a). We first notice that the overlay has a very high entropy which is somewhat interesting

![Overlay entropy value](/images/blank-grabber-overlay-entropy.png)

If we scroll a bit lower we see UnpacMe has extracted quite a few files for us and it's even provided us with a brief overview of what the files do ❤️. It also allows us to download each extracted file.

![Unpacme unpacking result](/images/blank-grabber-unpacme-decompiled-files.png)

![Unpacme unpacked files](/images/blank-grabber-all-unpacked-files.png)

## Reversing the main pyc file

If we take the file titled `31da8165-1390-4961-9dda-f70b7d9e9a79.pyc` and pass it to [PyLingual](https://pylingual.io/) we can get a perfectly reversed Python script. Upon reviewing it, we see it's fairly simple.

```python
# Decompiled with PyLingual (https://pylingual.io)
# Internal filename: loader-o.py
# Bytecode version: 3.13.0rc3 (3571)
# Source timestamp: 1970-01-01 00:00:00 UTC (0)

import os
import sys
import base64
import zlib
from pyaes import AESModeOfOperationGCM
from zipimport import zipimporter
zipfile = os.path.join(sys._MEIPASS, 'blank.aes')
module = 'stub-o'
key = base64.b64decode('lWLqAOPPVuwIsc2H67NJ2Z/IJxVtYdpcyDQQxhN0o7I=')
iv = base64.b64decode('s83KOFdOnbp77JPN')

def decrypt(key, iv, ciphertext):
    return AESModeOfOperationGCM(key, iv).decrypt(ciphertext)
if os.path.isfile(zipfile):
    with open(zipfile, 'rb') as f:
        ciphertext = f.read()
    ciphertext = zlib.decompress(ciphertext[::-1])
    decrypted = decrypt(key, iv, ciphertext)
    with open(zipfile, 'wb') as f:
        f.write(decrypted)
    zipimporter(zipfile).load_module(module)
```
It starts by loading a file called "blank.aes", it reads it's content, reverses it, decrypts it, writes it to a file and imports (and executes) a module called `stub-o`. If you try to run it however you'll notice that PyAES doesn't actually have a function called `AESModeOfOperationGCM`. I'm not gonna lie, this got me confused for quite a bit but after a bit, I ended up realizing it was relying on a modified version of PyAES. Thankfully for us, AESModeOfOperationGCM was re-implemented in the [Grabbers-Deobfuscator](https://github.com/TaxMachine/Grabbers-Deobfuscator) repository.

{{< emgithub target="https://github.com/TaxMachine/Grabbers-Deobfuscator/blob/089c23e2a2747ffeef652ba18ee49f34f0775e27/utils/pyaes/aes.py#L581-L589" lang="py" >}}